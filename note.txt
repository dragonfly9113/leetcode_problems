

Note of Leetcode problems


Git hub token for use on Q laptop:

git config credential.helper store
dragonfly9113
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



---------------------
11/06/2021 Sat
---------------------

/*
	344. Reverse String

	Write a function that reverses a string. The input string is given as an array of characters s.

	Example 1:
	Input: s = ["h","e","l","l","o"]
	Output: ["o","l","l","e","h"]

	Example 2:
	Input: s = ["H","a","n","n","a","h"]
	Output: ["h","a","n","n","a","H"]

	Constraints:
	1 <= s.length <= 105
	s[i] is a printable ascii character.

	Follow up: Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.
*/

/*
Note 1: The difference between char* str and char str[]:
char* str = "hello";
In this case, an unamed array will be created to hold the string litery. Then the pointer to the first element &unamed[0] will be assigned to str.
Sinde this is a string litery, it is liked that the storage of the unamed array will be put into read-only section. Thus trying to modify the string through
pointer str will cause UB (undefined behaviour)!

char str[] = "hello";
In this case, an array named "str" is created. The storage will most likely be in the stack if this statement is in a function. Modifying the string through
pointer str is OK. Passing the pointer to another function for manipulation is also OK.

Note 2: sizeof() v.s. strlen()
Based on the previous example:
sizeof(str) = 6
strlen(str) = 5

Please note that when we initialize a string like above, a nul char '\0' is appended at the end of string by compiler:
str[] = {'h', 'e', 'l', 'l', 'o', '\0'};

Therefore, sizeof(str) = 6 because sizeof() counts the number of all elements (including the nul char) in the array in bytes and because sizeof(char) = 1.
The strlen() is a function defined in standard C lib and it will count all chars in a string (excluding the nul char). We need to #include <string.h> to use it.

Note 3: The difference between the following array initialization:
char str[] = "hello";
char str[] = {'h', 'e', 'l', 'l', 'o'};

The first one is to use a string litary to initialize an array and it will append a nul char at the end of array. So the size of the array is 6.
The second one is to use {} clause to initialize an array and so str will treated just like an array (not a string). No nul char will be appended and the size is 5.
*/

#include <stdio.h>
#include <string.h>

// Use two pointers
void reverseString(char* s, int sSize){
	char* p = s;
	char* q = s + sSize - 1;
	
	while (p < q) {
		char t = *p;
		*p = *q;
		*q = t;
		p++;
		q--;
	}

	return;
}

// Use index instead of pointer
void reverseString_index(char* s, int sSize){
	int i = 0;
	int j = sSize - 1;

	while (i < j) {
		char t = s[i];
		s[i] = s[j];
		s[j] = t;
		i++;
		j--;
	}

	return;
}

int main()
{
	char str1[] = "hello";
	char str2[] = "Hannah";
	
	reverseString(str1, strlen(str1));
	printf("str1 = %s\n", str1);
	
	reverseString(str2, 6);
	printf("str2 = %s\n", str2);

	return 0;
}



---------------------
11/07/2021 Sun
---------------------

/*
541. Reverse String II

Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.

If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.

Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"

Example 2:
Input: s = "abcd", k = 2
Output: "bacd"

Constraints:
1 <= s.length <= 104
s consists of only lowercase English letters.
1 <= k <= 104
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MIN(a,b) ((a) < (b) ? (a) : (b))

void reverseString(char* s, int sSize){
	char* p = s;
	char* q = s + sSize - 1;
	
	while (p < q) {
		char t = *p;
		*p = *q;
		*q = t;
		p++;
		q--;
	}

	return;
}

/*
Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.

If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
*/
char * reverseStr_1(char* s, int k) {
	int sSize = strlen(s);
	char* p = s;
	char* q = s + sSize - 1;

	while (p <= q) {
		int cLeft = q - p + 1;	// cLeft is the number charaters left from the current p position.

		if (cLeft < k)
			reverseString(p, cLeft);
		else
			reverseString(p, k);

		p += 2 * k;		
	}

	return s;
}

/*
Use MIN() to avoid using if..else.. clause.
*/
char * reverseStr(char* s, int k) {
	int sSize = strlen(s);
	char* p = s;
	char* q = s + sSize - 1;

	while (p <= q) {
		int cLeft = q - p + 1;	// cLeft is the number charaters left from the current p position.
		reverseString(p, MIN(cLeft, k));

		p += 2 * k;		
	}

	return s;
}

/*
Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"

Example 2:
Input: s = "abcd", k = 2
Output: "bacd"
*/
int main()
{
	char str1[] = "abcdefg";
	int k1 = 2;
	char str2[] = "abcd";
	int k2 = 2;

	reverseStr(str1, k1);
	printf("str1 = %s\n", str1);
	
	reverseStr(str2, k2);
	printf("str2 = %s\n", str2);

	return 0;
}



---------------------
11/10/2021 Wed
---------------------

/*
2011. Final Value of Variable After Performing Operations
2011_final_value_after_ops.c

There is a programming language with only four operations and one variable X:
++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

Example 1:
Input: operations = ["--X","X++","X++"]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.

Example 2:
Input: operations = ["++X","++X","X++"]
Output: 3
Explanation: The operations are performed as follows:
Initially, X = 0.
++X: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
X++: X is incremented by 1, X = 2 + 1 = 3.

Example 3:
Input: operations = ["X++","++X","--X","X--"]
Output: 0
Explanation: The operations are performed as follows:
Initially, X = 0.
X++: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
--X: X is decremented by 1, X = 2 - 1 = 1.
X--: X is decremented by 1, X = 1 - 1 = 0.

Constraints:
1 <= operations.length <= 100
operations[i] will be either "++X", "X++", "--X", or "X--".
*/
#include <stdio.h>
#include <string.h>

/*
First version
*/
int finalValueAfterOperations_1(char ** operations, int operationsSize){
    int x = 0;

    for (int i = 0; i < operationsSize; i++) {
        if (strcmp(operations[i], "++X") == 0 || strcmp(operations[i], "X++") == 0)
            x++;
        else
            x--;
    }

    return x;
}

/*
Second version - Wrong!

In C, we cannot use "==" or "!=" to compare two strings. The following function might seem to work though. This is because "==" actaully compares the base addresses of the two sides. Here operations[i] is a pointer to char that points to unnamed string literary "++X" and "X++", so they might return true. But the behaviour is undefined. When I ran this program locally it seems to pass but it failed to pass the online tester of Leetcode.
*/
int finalValueAfterOperations_2(char ** operations, int operationsSize){
    int x = 0;

    for (int i = 0; i < operationsSize; i++) {
        if (operations[i] == "++X" || operations[i] == "X++")
            x++;
        else
            x--;
    }

    return x;
}

/*
Version 3

Note that the second char of both "++X" and "X++" is '+' and the second char of both "--X" and "X--" is '-'.
This observation should make the comparison a little easer!

And note that a char in C is actually an integer between 1 and 255, and thus can be compared with comparison ops.
*/
int finalValueAfterOperations(char ** operations, int operationsSize){
    int x = 0;

    for (int i = 0; i < operationsSize; i++) {
        if (operations[i][1] == '+')
            x++;
        else
            x--;
    }

    return x;
}


/*
Example 1:
Input: operations = ["--X","X++","X++"]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.

Example 2:
Input: operations = ["++X","++X","X++"]
Output: 3
Explanation: The operations are performed as follows:
Initially, X = 0.
++X: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
X++: X is incremented by 1, X = 2 + 1 = 3.

Example 3:
Input: operations = ["X++","++X","--X","X--"]
Output: 0
Explanation: The operations are performed as follows:
Initially, X = 0.
X++: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
--X: X is decremented by 1, X = 2 - 1 = 1.
X--: X is decremented by 1, X = 1 - 1 = 0.
*/
int main()
{
    int output1 = 0;
    char* ops1[] = {"--X","X++","X++"};
    int ops_size1 = sizeof(ops1) / sizeof(char*);

    int output2 = 0;
    char* ops2[] = {"++X","++X","X++"};
    int ops_size2 = sizeof(ops2) / sizeof(char*);

    int output3 = 0;
    char* ops3[] = {"X++","++X","--X","X--"};
    int ops_size3 = sizeof(ops3) / sizeof(char*);

    output1 = finalValueAfterOperations(ops1, ops_size1);
    printf("ops_size1 = %d\n", ops_size1);
    printf("output1 = %d\n", output1);

    output2 = finalValueAfterOperations(ops2, ops_size2);
    printf("ops_size2 = %d\n", ops_size2);
    printf("output2 = %d\n", output2);

    output3 = finalValueAfterOperations(ops3, ops_size3);
    printf("ops_size3 = %d\n", ops_size3);
    printf("output3 = %d\n", output3);

	return 0;
}



/*
1108. Defanging an IP Address
1108_defanging_IP_addr.c

Given a valid (IPv4) IP address, return a defanged version of that IP address.
A defanged IP address replaces every period "." with "[.]".

Example 1:
Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"

Example 2:
Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"

Constraints:
The given address is a valid IPv4 address.
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
First version
*/
char * defangIPaddr_1(char * address) {
    int addrLen = strlen(address);
    int defangedLen = addrLen + 6;
    char* defanged_addr = malloc(defangedLen + 1);

    int j = 0;
    for (int i = 0; i < addrLen; i++) {
        if (address[i] != '.') {
            defanged_addr[j++] = address[i];
        }
        else {
            defanged_addr[j++] = '[';
            defanged_addr[j++] = '.';
            defanged_addr[j++] = ']';
        }
    }

    defanged_addr[defangedLen] = '\0';
    return defanged_addr;
}

/*
Version 2
Use pointer instead of index.
*/
char * defangIPaddr(char * address) {
    int addrLen = strlen(address);
    int defangedLen = addrLen + 6;
    char* defanged_addr = malloc(defangedLen + 1);

    char* p = address;
    char* q = defanged_addr;
    while (p < address + addrLen) {
        if (*p != '.') {
            *q++ = *p;
        }
        else {
            *q++ = '[';
            *q++ = '.';
            *q++ = ']';
        }
        p++;
    }

    defanged_addr[defangedLen] = '\0';
    return defanged_addr;
}

/*
Example 1:
Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"

Example 2:
Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
*/
int main() {
    char* addr1 = "1.1.1.1";
    char* addr2 = "255.100.50.0";

    char* output;

    output = defangIPaddr(addr1);
    printf("output = %s\n", output);

    if (output) {
        free(output);
        output = NULL;
    }

    output = defangIPaddr(addr2);
    printf("output = %s\n", output);

    if (output) {
        free(output);
        output = NULL;
    }

    return 0;
}



---------------------
11/11/2021 Thu
---------------------

/*
771. Jewels and Stones
771_jewels_stones.c

You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.
Letters are case sensitive, so "a" is considered a different type of stone from "A".

Example 1:
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3

Example 2:
Input: jewels = "z", stones = "ZZ"
Output: 0

Constraints:
1 <= jewels.length, stones.length <= 50
jewels and stones consist of only English letters.
All the characters of jewels are unique.
*/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

/*
Version 1
Brute Force version
time complexity = O(M*N)
*/
bool isJewel(char* jewels, char oneStone) {
    char* j = jewels;

    while (*j) {
        if (oneStone == *j)
            return true;
        j++;
    }
    return false;
}

int numJewelsInStones_1(char * jewels, char * stones) {
    char* s = stones;
    int count = 0;

    while (*s) {
        if (isJewel(jewels, *s))
            count++;
        s++;
    }

    return count;
}

/*
Version 2
Consider that an English letter is an ASCII symbol and can be easily converted to an integer, which can be then used as an index of array. Thus an array of letters can be easily converted to an array of integers with each letter as index.
Then we can take advantage of the O(1) search charater of array to check if a stone is a jewel or not.
Time Complexity: O(M+N)
*/
int numJewelsInStones_2(char * jewels, char * stones) {
    int count = 0;
    int jewelTable['z' - 'A' + 1] = {0};

    while (*jewels) {
        jewelTable[*jewels - 'A'] = 1;
        jewels++;
    }    

    while (*stones) {
        if (jewelTable[*stones - 'A'] == 1)
            count++;
        stones++;
    }

    return count;
}

/*
Version 3 - from discussions
Improvements from version 2:
1. No need to calculate the length of jewel table. Since we know that letter z (the biggest one) is less than 128, we can just define a table of 128 to cover all English letters.
2. The for loop can be more neat than while loop, and no need to calculate array size.
3. For table index, no need to calculate *p - 'A' since we have an arr[128] to cover all.
4. No need to use if clause.

Note: similar method uses unordered_map in C++, and HashSet in Java.
*/
int numJewelsInStones(char * jewels, char * stones) {
    int a = 0;
    char t[128] = {};

    for (char* p = jewels; *p; p++) t[*p] = (char) 1;
    for (char* p = stones; *p; p++) a += t[*p];    

    return a;
}

/*
Example 1:
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3

Example 2:
Input: jewels = "z", stones = "ZZ"
Output: 0
*/
int main() {
    char* jewels1 = "aA";
    char* jewels2 = "z";

    char* stones1 = "aAAbbbb";
    char* stones2 = "ZZ";

    int output1 = numJewelsInStones(jewels1, stones1);
    int output2 = numJewelsInStones(jewels2, stones2);

    printf("output1 = %d\n", output1);
    printf("output2 = %d\n", output2);

    return 0;
}





















