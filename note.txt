

Note of Leetcode problems


Git hub token for use on Q laptop:

git config credential.helper store
dragonfly9113
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



---------------------
11/06/2021 Sat
---------------------

/*
	344. Reverse String

	Write a function that reverses a string. The input string is given as an array of characters s.

	Example 1:
	Input: s = ["h","e","l","l","o"]
	Output: ["o","l","l","e","h"]

	Example 2:
	Input: s = ["H","a","n","n","a","h"]
	Output: ["h","a","n","n","a","H"]

	Constraints:
	1 <= s.length <= 105
	s[i] is a printable ascii character.

	Follow up: Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.
*/

/*
Note 1: The difference between char* str and char str[]:
char* str = "hello";
In this case, an unamed array will be created to hold the string litery. Then the pointer to the first element &unamed[0] will be assigned to str.
Sinde this is a string litery, it is liked that the storage of the unamed array will be put into read-only section. Thus trying to modify the string through
pointer str will cause UB (undefined behaviour)!

char str[] = "hello";
In this case, an array named "str" is created. The storage will most likely be in the stack if this statement is in a function. Modifying the string through
pointer str is OK. Passing the pointer to another function for manipulation is also OK.

Note 2: sizeof() v.s. strlen()
Based on the previous example:
sizeof(str) = 6
strlen(str) = 5

Please note that when we initialize a string like above, a nul char '\0' is appended at the end of string by compiler:
str[] = {'h', 'e', 'l', 'l', 'o', '\0'};

Therefore, sizeof(str) = 6 because sizeof() counts the number of all elements (including the nul char) in the array in bytes and because sizeof(char) = 1.
The strlen() is a function defined in standard C lib and it will count all chars in a string (excluding the nul char). We need to #include <string.h> to use it.

Note 3: The difference between the following array initialization:
char str[] = "hello";
char str[] = {'h', 'e', 'l', 'l', 'o'};

The first one is to use a string litary to initialize an array and it will append a nul char at the end of array. So the size of the array is 6.
The second one is to use {} clause to initialize an array and so str will treated just like an array (not a string). No nul char will be appended and the size is 5.
*/

#include <stdio.h>
#include <string.h>

// Use two pointers
void reverseString(char* s, int sSize){
	char* p = s;
	char* q = s + sSize - 1;
	
	while (p < q) {
		char t = *p;
		*p = *q;
		*q = t;
		p++;
		q--;
	}

	return;
}

// Use index instead of pointer
void reverseString_index(char* s, int sSize){
	int i = 0;
	int j = sSize - 1;

	while (i < j) {
		char t = s[i];
		s[i] = s[j];
		s[j] = t;
		i++;
		j--;
	}

	return;
}

int main()
{
	char str1[] = "hello";
	char str2[] = "Hannah";
	
	reverseString(str1, strlen(str1));
	printf("str1 = %s\n", str1);
	
	reverseString(str2, 6);
	printf("str2 = %s\n", str2);

	return 0;
}



---------------------
11/07/2021 Sun
---------------------

/*
541. Reverse String II

Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.

If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.

Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"

Example 2:
Input: s = "abcd", k = 2
Output: "bacd"

Constraints:
1 <= s.length <= 104
s consists of only lowercase English letters.
1 <= k <= 104
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MIN(a,b) ((a) < (b) ? (a) : (b))

void reverseString(char* s, int sSize){
	char* p = s;
	char* q = s + sSize - 1;
	
	while (p < q) {
		char t = *p;
		*p = *q;
		*q = t;
		p++;
		q--;
	}

	return;
}

/*
Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.

If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
*/
char * reverseStr_1(char* s, int k) {
	int sSize = strlen(s);
	char* p = s;
	char* q = s + sSize - 1;

	while (p <= q) {
		int cLeft = q - p + 1;	// cLeft is the number charaters left from the current p position.

		if (cLeft < k)
			reverseString(p, cLeft);
		else
			reverseString(p, k);

		p += 2 * k;		
	}

	return s;
}

/*
Use MIN() to avoid using if..else.. clause.
*/
char * reverseStr(char* s, int k) {
	int sSize = strlen(s);
	char* p = s;
	char* q = s + sSize - 1;

	while (p <= q) {
		int cLeft = q - p + 1;	// cLeft is the number charaters left from the current p position.
		reverseString(p, MIN(cLeft, k));

		p += 2 * k;		
	}

	return s;
}

/*
Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"

Example 2:
Input: s = "abcd", k = 2
Output: "bacd"
*/
int main()
{
	char str1[] = "abcdefg";
	int k1 = 2;
	char str2[] = "abcd";
	int k2 = 2;

	reverseStr(str1, k1);
	printf("str1 = %s\n", str1);
	
	reverseStr(str2, k2);
	printf("str2 = %s\n", str2);

	return 0;
}



---------------------
11/10/2021 Wed
---------------------

/*
2011. Final Value of Variable After Performing Operations
2011_final_value_after_ops.c

There is a programming language with only four operations and one variable X:
++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.

Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.

Example 1:
Input: operations = ["--X","X++","X++"]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.

Example 2:
Input: operations = ["++X","++X","X++"]
Output: 3
Explanation: The operations are performed as follows:
Initially, X = 0.
++X: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
X++: X is incremented by 1, X = 2 + 1 = 3.

Example 3:
Input: operations = ["X++","++X","--X","X--"]
Output: 0
Explanation: The operations are performed as follows:
Initially, X = 0.
X++: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
--X: X is decremented by 1, X = 2 - 1 = 1.
X--: X is decremented by 1, X = 1 - 1 = 0.

Constraints:
1 <= operations.length <= 100
operations[i] will be either "++X", "X++", "--X", or "X--".
*/
#include <stdio.h>
#include <string.h>

/*
First version
*/
int finalValueAfterOperations_1(char ** operations, int operationsSize){
    int x = 0;

    for (int i = 0; i < operationsSize; i++) {
        if (strcmp(operations[i], "++X") == 0 || strcmp(operations[i], "X++") == 0)
            x++;
        else
            x--;
    }

    return x;
}

/*
Second version - Wrong!

In C, we cannot use "==" or "!=" to compare two strings. The following function might seem to work though. This is because "==" actaully compares the base addresses of the two sides. Here operations[i] is a pointer to char that points to unnamed string literary "++X" and "X++", so they might return true. But the behaviour is undefined. When I ran this program locally it seems to pass but it failed to pass the online tester of Leetcode.
*/
int finalValueAfterOperations_2(char ** operations, int operationsSize){
    int x = 0;

    for (int i = 0; i < operationsSize; i++) {
        if (operations[i] == "++X" || operations[i] == "X++")
            x++;
        else
            x--;
    }

    return x;
}

/*
Version 3

Note that the second char of both "++X" and "X++" is '+' and the second char of both "--X" and "X--" is '-'.
This observation should make the comparison a little easer!

And note that a char in C is actually an integer between 1 and 255, and thus can be compared with comparison ops.
*/
int finalValueAfterOperations(char ** operations, int operationsSize){
    int x = 0;

    for (int i = 0; i < operationsSize; i++) {
        if (operations[i][1] == '+')
            x++;
        else
            x--;
    }

    return x;
}


/*
Example 1:
Input: operations = ["--X","X++","X++"]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.

Example 2:
Input: operations = ["++X","++X","X++"]
Output: 3
Explanation: The operations are performed as follows:
Initially, X = 0.
++X: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
X++: X is incremented by 1, X = 2 + 1 = 3.

Example 3:
Input: operations = ["X++","++X","--X","X--"]
Output: 0
Explanation: The operations are performed as follows:
Initially, X = 0.
X++: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
--X: X is decremented by 1, X = 2 - 1 = 1.
X--: X is decremented by 1, X = 1 - 1 = 0.
*/
int main()
{
    int output1 = 0;
    char* ops1[] = {"--X","X++","X++"};
    int ops_size1 = sizeof(ops1) / sizeof(char*);

    int output2 = 0;
    char* ops2[] = {"++X","++X","X++"};
    int ops_size2 = sizeof(ops2) / sizeof(char*);

    int output3 = 0;
    char* ops3[] = {"X++","++X","--X","X--"};
    int ops_size3 = sizeof(ops3) / sizeof(char*);

    output1 = finalValueAfterOperations(ops1, ops_size1);
    printf("ops_size1 = %d\n", ops_size1);
    printf("output1 = %d\n", output1);

    output2 = finalValueAfterOperations(ops2, ops_size2);
    printf("ops_size2 = %d\n", ops_size2);
    printf("output2 = %d\n", output2);

    output3 = finalValueAfterOperations(ops3, ops_size3);
    printf("ops_size3 = %d\n", ops_size3);
    printf("output3 = %d\n", output3);

	return 0;
}



/*
1108. Defanging an IP Address
1108_defanging_IP_addr.c

Given a valid (IPv4) IP address, return a defanged version of that IP address.
A defanged IP address replaces every period "." with "[.]".

Example 1:
Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"

Example 2:
Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"

Constraints:
The given address is a valid IPv4 address.
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
First version
*/
char * defangIPaddr_1(char * address) {
    int addrLen = strlen(address);
    int defangedLen = addrLen + 6;
    char* defanged_addr = malloc(defangedLen + 1);

    int j = 0;
    for (int i = 0; i < addrLen; i++) {
        if (address[i] != '.') {
            defanged_addr[j++] = address[i];
        }
        else {
            defanged_addr[j++] = '[';
            defanged_addr[j++] = '.';
            defanged_addr[j++] = ']';
        }
    }

    defanged_addr[defangedLen] = '\0';
    return defanged_addr;
}

/*
Version 2
Use pointer instead of index.
*/
char * defangIPaddr(char * address) {
    int addrLen = strlen(address);
    int defangedLen = addrLen + 6;
    char* defanged_addr = malloc(defangedLen + 1);

    char* p = address;
    char* q = defanged_addr;
    while (p < address + addrLen) {
        if (*p != '.') {
            *q++ = *p;
        }
        else {
            *q++ = '[';
            *q++ = '.';
            *q++ = ']';
        }
        p++;
    }

    defanged_addr[defangedLen] = '\0';
    return defanged_addr;
}

/*
Example 1:
Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"

Example 2:
Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
*/
int main() {
    char* addr1 = "1.1.1.1";
    char* addr2 = "255.100.50.0";

    char* output;

    output = defangIPaddr(addr1);
    printf("output = %s\n", output);

    if (output) {
        free(output);
        output = NULL;
    }

    output = defangIPaddr(addr2);
    printf("output = %s\n", output);

    if (output) {
        free(output);
        output = NULL;
    }

    return 0;
}



---------------------
11/11/2021 Thu
---------------------

/*
771. Jewels and Stones
771_jewels_stones.c

You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.
Letters are case sensitive, so "a" is considered a different type of stone from "A".

Example 1:
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3

Example 2:
Input: jewels = "z", stones = "ZZ"
Output: 0

Constraints:
1 <= jewels.length, stones.length <= 50
jewels and stones consist of only English letters.
All the characters of jewels are unique.
*/

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

/*
Version 1
Brute Force version
time complexity = O(M*N)
*/
bool isJewel(char* jewels, char oneStone) {
    char* j = jewels;

    while (*j) {
        if (oneStone == *j)
            return true;
        j++;
    }
    return false;
}

int numJewelsInStones_1(char * jewels, char * stones) {
    char* s = stones;
    int count = 0;

    while (*s) {
        if (isJewel(jewels, *s))
            count++;
        s++;
    }

    return count;
}

/*
Version 2
Consider that an English letter is an ASCII symbol and can be easily converted to an integer, which can be then used as an index of array. Thus an array of letters can be easily converted to an array of integers with each letter as index.
Then we can take advantage of the O(1) search charater of array to check if a stone is a jewel or not.
Time Complexity: O(M+N)
*/
int numJewelsInStones_2(char * jewels, char * stones) {
    int count = 0;
    int jewelTable['z' - 'A' + 1] = {0};

    while (*jewels) {
        jewelTable[*jewels - 'A'] = 1;
        jewels++;
    }    

    while (*stones) {
        if (jewelTable[*stones - 'A'] == 1)
            count++;
        stones++;
    }

    return count;
}

/*
Version 3 - from discussions
Improvements from version 2:
1. No need to calculate the length of jewel table. Since we know that letter z (the biggest one) is less than 128, we can just define a table of 128 to cover all English letters.
2. The for loop can be more neat than while loop, and no need to calculate array size.
3. For table index, no need to calculate *p - 'A' since we have an arr[128] to cover all.
4. No need to use if clause.

Note: similar method uses unordered_map in C++, and HashSet in Java.
*/
int numJewelsInStones(char * jewels, char * stones) {
    int a = 0;
    char t[128] = {};

    for (char* p = jewels; *p; p++) t[*p] = (char) 1;
    for (char* p = stones; *p; p++) a += t[*p];    

    return a;
}

/*
Example 1:
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3

Example 2:
Input: jewels = "z", stones = "ZZ"
Output: 0
*/
int main() {
    char* jewels1 = "aA";
    char* jewels2 = "z";

    char* stones1 = "aAAbbbb";
    char* stones2 = "ZZ";

    int output1 = numJewelsInStones(jewels1, stones1);
    int output2 = numJewelsInStones(jewels2, stones2);

    printf("output1 = %d\n", output1);
    printf("output2 = %d\n", output2);

    return 0;
}



---------------------
11/12/2021 Fri
---------------------

/*
1528. Shuffle String
1528_shuffle_string.c

Given a string s and an integer array indices of the same length.
The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.
Return the shuffled string.

Example 1:
Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.

Example 2:
Input: s = "abc", indices = [0,1,2]
Output: "abc"
Explanation: After shuffling, each character remains in its position.

Example 3:
Input: s = "aiohn", indices = [3,1,4,2,0]
Output: "nihao"

Example 4:
Input: s = "aaiougrt", indices = [4,0,2,6,7,3,1,5]
Output: "arigatou"

Example 5:
Input: s = "art", indices = [1,0,2]
Output: "rat"

Constraints:
s.length == indices.length == n
1 <= n <= 100
s contains only lower-case English letters.
0 <= indices[i] < n
All values of indices are unique (i.e. indices is a permutation of the integers from 0 to n - 1).
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
C calloc() method
“calloc” or “contiguous allocation” method in C is used to dynamically allocate the specified number of blocks of memory of the specified type. it is very much similar to malloc() but has two different points and these are:
1. It initializes each block with a default value ‘0’.
2. It has two parameters or arguments as compare to malloc().
Syntax: 
ptr = (cast-type*)calloc(n, element-size);
here, n is the no. of elements and element-size is the size of each element.
Example:
floag* ptr = (float*) calloc(25, sizeof(float));
*/

/*
Version 1
Time:   O(N)
Space:  O(N)
*/
char * restoreString_1(char * s, int* indices, int indicesSize){
    //char* p = (char*) malloc((indicesSize + 1) * sizeof(char));
    char* p = (char*) calloc(indicesSize + 1, sizeof(char));
    if(!p) {
        printf("calloc() failed\n");
        exit(1);
    }

    for (int i = 0; i < indicesSize; i++) p[indices[i]] = s[i];

    p[indicesSize] = '\0';
    return p;
}

/*
Version 2
Time:   O(N)
Space:  O(1)

Instead of copying chars in s to a new array, we now do swapping in place in s:
swap s[indices[i]] and s[i] is to make sure s[i] is placed at correct position in s.
swap indices[indices[i]] and indices[i] is to make sure indices[i] is placed at correct position in indices.
i will only be incremented if i == indices[i], which means indices[i] is already at correct position in indices.

Keep doing the above swappings until all elements in indices are in right positions: indices = [0,1,2,3,4....]. At that point, we can also be sure that all elements in s are all in right positions too.

Note: main() needs to make sure s is defined as an array, not a pointer to string literary to allow in-place modification:
char s[] = "codeleet";  <-- OK!
char* s = "codeleet";   <-- NOt OK!
*/
char * restoreString(char * s, int* indices, int indicesSize){
    int i = 0;
    while (i < indicesSize) {
        if (i == indices[i]) i++;
        else {
            char t = s[indices[i]];
            s[indices[i]] = s[i];
            s[i] = t;

            int j = indices[indices[i]];
            indices[indices[i]] = indices[i];
            indices[i] = j;
        }
    }
    return s;
}

/*
Example 1:
Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
Output: "leetcode"
Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.

Example 2:
Input: s = "abc", indices = [0,1,2]
Output: "abc"
Explanation: After shuffling, each character remains in its position.

Example 3:
Input: s = "aiohn", indices = [3,1,4,2,0]
Output: "nihao"

Example 4:
Input: s = "aaiougrt", indices = [4,0,2,6,7,3,1,5]
Output: "arigatou"

Example 5:
Input: s = "art", indices = [1,0,2]
Output: "rat"
*/
int main_1() {
    char* s1 = "codeleet";
    int indices1[] = {4,5,6,7,0,2,1,3};
    char* s2 = "abc";
    int indices2[] = {0,1,2};
    char* s3 = "aiohn";
    int indices3[] = {3,1,4,2,0};
    char* s4 = "aaiougrt";
    int indices4[] = {4,0,2,6,7,3,1,5};
    char* s5 = "art";
    int indices5[] = {1,0,2};

    char* o;
    o = restoreString(s1, indices1, sizeof(indices1)/sizeof(int));
    printf("o = %s\n", o);
    free(o);
    o = restoreString(s2, indices2, sizeof(indices2)/sizeof(int));
    printf("o = %s\n", o);
    free(o);
    o = restoreString(s3, indices3, sizeof(indices3)/sizeof(int));
    printf("o = %s\n", o);
    free(o);
    o = restoreString(s4, indices4, sizeof(indices4)/sizeof(int));
    printf("o = %s\n", o);
    free(o);
    o = restoreString(s5, indices5, sizeof(indices5)/sizeof(int));
    printf("o = %s\n", o);
    free(o);

    return 0;
}

int main() {
    char s1[] = "codeleet";
    int indices1[] = {4,5,6,7,0,2,1,3};
    char s2[] = "abc";
    int indices2[] = {0,1,2};
    char s3[] = "aiohn";
    int indices3[] = {3,1,4,2,0};
    char s4[] = "aaiougrt";
    int indices4[] = {4,0,2,6,7,3,1,5};
    char s5[] = "art";
    int indices5[] = {1,0,2};

    restoreString(s1, indices1, sizeof(indices1)/sizeof(int));
    printf("s1 = %s\n", s1);
    restoreString(s2, indices2, sizeof(indices2)/sizeof(int));
    printf("s2 = %s\n", s2);
    restoreString(s3, indices3, sizeof(indices3)/sizeof(int));
    printf("s3 = %s\n", s3);
    restoreString(s4, indices4, sizeof(indices4)/sizeof(int));
    printf("s4 = %s\n", s4);
    restoreString(s5, indices5, sizeof(indices5)/sizeof(int));
    printf("s5 = %s\n", s5);

    return 0;
}



/*
1678. Goal Parser Interpretation
1678_goal_parser.c

You own a Goal Parser that can interpret a string command. The command consists of an alphabet of "G", "()" and/or "(al)" in some order. The Goal Parser will interpret "G" as the string "G", "()" as the string "o", and "(al)" as the string "al". The interpreted strings are then concatenated in the original order.
Given the string command, return the Goal Parser's interpretation of command.

Example 1:
Input: command = "G()(al)"
Output: "Goal"
Explanation: The Goal Parser interprets the command as follows:
G -> G
() -> o
(al) -> al
The final concatenated result is "Goal".

Example 2:
Input: command = "G()()()()(al)"
Output: "Gooooal"

Example 3:
Input: command = "(al)G(al)()()G"
Output: "alGalooG"

Constraints:
1 <= command.length <= 100
command consists of "G", "()", and/or "(al)" in some order.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
Version 1
Time: O(N)
Space: O(N)
*/
char * interpret_1(char * command){
    char* out = (char*) calloc(100, sizeof(char));
    if (!out) {
        printf("calloc() failed!\n");
        exit(1);
    }

    char* p = command;
    char* q = out;
    while (*p) {
        if (*p == 'G') {
            *q = 'G'; q++;
            p++;
        }
        else if (*p == '(' && *(p+1) == ')') {
            *q = 'o'; q++;
            p += 2;
        }
        else {
            *q = 'a'; q++;
            *q = 'l'; q++;
            p += 4;
        }
    }

    *q = '\0';
    return out;
}

/*
Version 2
Time: O(N)
Space: O(1)

No need to have an extra array. Just update the original array and two pointers. The pointer p is used to check pattern and the pointer q is used to update. The reason we can do this is because p will move faster than the update pointer q.
*/
char * interpret_2(char * command){
    char* p = command;
    char* q = command;

    while (*p) {
        if (*p == 'G') {
            *q = 'G'; q++;
            p++;
        }
        else if (*p == '(' && *(p+1) == ')') {
            *q = 'o'; q++;
            p += 2;
        }
        else {
            *q = 'a'; q++;
            *q = 'l'; q++;
            p += 4;
        }
    }

    *q = '\0';
    return command;
}

/*
Version 3
Time: O(N)
Space: O(1)

Similar to version 2. Simplify else if clause a little.
*/
char * interpret(char * command){
    char* p = command;
    char* q = command;

    while (*p) {
        if (*p == 'G') {
            *q = 'G'; q++;
            p++;
        }
        else if (*(p+1) == ')') {
            *q = 'o'; q++;
            p += 2;
        }
        else {
            *q = 'a'; q++;
            *q = 'l'; q++;
            p += 4;
        }
    }

    *q = '\0';
    return command;
}

/*
Example 1:
Input: command = "G()(al)"
Output: "Goal"
Explanation: The Goal Parser interprets the command as follows:
G -> G
() -> o
(al) -> al
The final concatenated result is "Goal".

Example 2:
Input: command = "G()()()()(al)"
Output: "Gooooal"

Example 3:
Input: command = "(al)G(al)()()G"
Output: "alGalooG"
*/
int main () {
    char c1[] = "G()(al)";
    char c2[] = "G()()()()(al)";
    char c3[] = "(al)G(al)()()G";

    char* o1 = interpret(c1);
    printf("o1 = %s\n", o1);
    //free(o1);
    char* o2 = interpret(c2);
    printf("o2 = %s\n", o2);
    //free(o2);
    char* o3 = interpret(c3);
    printf("o3 = %s\n", o3);
    //free(o3);

    return 0;
}



/*
1221. Split a String in Balanced Strings
1221_split_in_balanced.c

Balanced strings are those that have an equal quantity of 'L' and 'R' characters.
Given a balanced string s, split it in the maximum amount of balanced strings.
Return the maximum amount of split balanced strings.

Example 1:
Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.

Example 2:
Input: s = "RLLLLRRRLR"
Output: 3
Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.

Example 3:
Input: s = "LLLLRRRR"
Output: 1
Explanation: s can be split into "LLLLRRRR".

Example 4:
Input: s = "RLRRRLLRLL"
Output: 2
Explanation: s can be split into "RL", "RRRLLRLL", since each substring contains an equal number of 'L' and 'R'

Constraints:
1 <= s.length <= 1000
s[i] is either 'L' or 'R'.
s is a balanced string.
*/

#include <stdio.h>
#include <string.h>

/*
Version 1
*/
int balancedStringSplit_1(char * s){
    int rc = 0;
    int lc = 0;
    int count = 0;

    while (*s) {
        if (*s == 'R')
            rc++;
        else
            lc++;

        if (rc > 0 && lc > 0 && rc == lc) {
            rc = 0; lc = 0; 
            count++;
        }
        s++;
    }

    return count;
}

/*
Version 2
Simplify the if clause of rc == lc a little. There is no need to check rc > 0 && lc > 0.
*/
int balancedStringSplit_2(char * s){
    int rc = 0;
    int lc = 0;
    int count = 0;

    while (*s) {
        if (*s == 'R')
            rc++;
        else
            lc++;

        if (rc == lc) {
            rc = 0; lc = 0; 
            count++;
        }
        s++;
    }

    return count;
}

/*
Version 3
A more compact version. Use only one variable sum instead of rc and lc.
*/
int balancedStringSplit(char * s){
    int sum = 0;
    int count = 0;

    for ( ; *s; s++) {
        sum += ((*s == 'R') ? 1 : -1);
        if (sum == 0) count++;
    }

    return count;
}

/*
Example 1:
Input: s = "RLRRLLRLRL"
Output: 4
Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.

Example 2:
Input: s = "RLLLLRRRLR"
Output: 3
Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.

Example 3:
Input: s = "LLLLRRRR"
Output: 1
Explanation: s can be split into "LLLLRRRR".

Example 4:
Input: s = "RLRRRLLRLL"
Output: 2
Explanation: s can be split into "RL", "RRRLLRLL", since each substring contains an equal number of 'L' and 'R'
*/
int main() {
    char s1[] = "RLRRLLRLRL";
    char s2[] = "RLLLLRRRLR";
    char s3[] = "LLLLRRRR";
    char s4[] = "RLRRRLLRLL";

    int count = 0;
    count = balancedStringSplit(s1);
    printf("count = %d\n", count);
    
    count = balancedStringSplit(s2);
    printf("count = %d\n", count);
    
    count = balancedStringSplit(s3);
    printf("count = %d\n", count);
    
    count = balancedStringSplit(s4);
    printf("count = %d\n", count);

    return 0;
}



---------------------
11/15/2021 Mon
---------------------

/*
Multidimensional array
0_multidimentional_array.c
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
To pass a string, we can use either char* or char[] (1D array).
*/
void print1D_1(char* item) {
    printf("item = %s\n", item);
}

void print1D(char item[]) {
    printf("item = %s\n", item);
}

/* 2D version 1:
When items1[][10] is defined using 2D array, the parameter of print2D() should also be defined as strs[][10]. Note that the second dimention size must be defined and match that of items1[][10].
The following two definitions do NOT work:
    void print2D_1(char* strs, int strsSize);     // Assume the incoming 2D array can be converted to a 1D array.
    void print2D_1(char** strs, int strsSize);    // Assume the incoming 2D array is the same as char** pointer.

We can see a big drawback of this funciton definition: it is NOT flexible at all. The first parameter MUST be char [][10]! Even the size of the second dimention is fixed!
*/
void print2D_1(char strs[][10], int strsSize) {
    for (int i = 0; i < strsSize; i++)
        printf("1%d: %s\n",i, strs[i]);
}

/* 2D version 2:
Since items2 is defined as an array of pointers, when it is passed as argument it is actually converted to char**. Thus here the first parameter of print2D_2 should be char**.
The function can also be defined as below:
    void print2D_2(char* strs[], int strsSize);
But the below definitions are NOT OK:
    void print2D_2(char* strs, int strsSize);
    void print2D_2(char strs[][10], int strsSize);

Note: I think this definition is better than that of 2D array. It is more flexible to use! This might be one of the reasons why array of pointers is more commonly used than multi-dimention arrays.
*/
void print2D_2(char** strs, int strsSize) {
    for (int i = 0; i < strsSize; i++)
        printf("2%d: %s\n",i, strs[i]);
}

/* 2D version 2.1:
Similar to print2D_2(). The difference: the array of pointers will be allocated dynamically and passed to this function.
Usually print2d_2() doesn't care how char** strs is allocated and initialized as long as strsSize is passed in. That's why print2D_2(char** strs, ..) is more flexible than the multidimensional array version.
*/
void print2D_2_1(char** strs, int strsSize) {
    for (int i = 0; i < strsSize; i++)
        printf("2.1%d: %s\n",i, strs[i]);
}

/* 2D version 2.2:
Similar to print2D_2_1(). The difference: instead of pointing to dynamically allocated memory space, each row pointer points to static anonymous string literal (likely in read-only memory region).
*/
void print2D_2_2(char** strs, int strsSize) {
    for (int i = 0; i < strsSize; i++)
        printf("2.2%d: %s\n",i, strs[i]);
}

/* 2D version 2.3:
The strs is defined as a 2D array but is casted as char* and passed here. The dimension bound info is lost during the cast process. Therefore we need to pass them in seperately as strsSize and colSize.
The strs in memory looks like a 1D array:
[Hello,\0....World!\0...]
 ^           ^
 0           10
When implementing print2D_2_3(), we need to explicitly use strsSize and colSize in order to properly use pointer strs. This is the drawback of this approach: implementing print2D_2_3() is a little more complex.
*/
void print2D_2_3(char* strs, int strsSize, int colSize) {
    for (int i = 0; i < strsSize; i++) {
        strs += i * colSize;
        printf("2.3%d: %s\n",i, strs);
    }
}

/* 3D version 1: 
The following definitions do NOT work:
    void print3D_2(char* strs, int strsSize);
    void print3D_2(char** strs, int strsSize);
    void print3D_2(char*** strs, int strsSize);

As we observed in 2D, this function definition is NOT flexible. Especially we must give the bounds of the second and the third dimensions as array type. This will greatly limit the usefulness of the function.
*/
void print3D_1(char strs[][3][10], int strsSize) {
    for (int i = 0; i < strsSize; i++) {
        printf("3D_1: ");
        for (int j = 0; j < 3; j++)
            printf("%s  ", strs[i][j]);
        printf("\n");
    }
}

/* 3D version 2:
A little better than version 1 as we only need to specify one bound.
But still not flexible.
*/
void print3D_2(char* strs[][3], int strsSize) {
    for (int i = 0; i < strsSize; i++) {
        printf("3D_2: ");
        for (int j = 0; j < 3; j++)
            printf("%s  ", strs[i][j]);
        printf("\n");
    }
}

/* 3D version 3:
The items5 (char ***) will be dynamically allocated and passed here. Since all pointers pointed to by items5 are allocated and initialized in a d1 * d2 array manner. Here we can access those pointers as in a d1 * d2 array.
*/
void print3D_3(char*** strs, int d1, int d2) {
    for (int i = 0; i < d1; i++) {
        printf("3D_3: ");        
        for (int j = 0; j < d2; j++)
            printf("%s  ", strs[i][j]);
        printf("\n");
    }
}

/* 3D version 3.1: Not OK!
//int d1 = 2, d2 = 3, d3 = 10;
//char items3[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}};
Convert the 3D array to 1D array and pass to print3D_3_1() as char *.
This one didn't work as expected and prints something like below, which is NOT correct!
3D_3_1: phone  blue  computer
3D_3_1:
*/
void print3D_3_1(char* strs, int d1, int d2, int d3) {
    for (int i = 0; i < d1; i++) {
        printf("3D_3_1: ");
        for (int j = 0; j < d2; j++) {
            strs += j * d3 + i * d2 * d3;
            printf("%s  ", strs);
        }
        printf("\n");
    }
}

/*
char items3[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}};
*/
int main() {

    char* item = "Hello, world!";
    //char item[] = "Hello, world!";        // This way is also OK!
    print1D(item);

    /* 2D version 1:
    Use a 2D array to hold multiple strings. Must indicate the dimentions for all inner dimentions. Only the most outer dimention does not need to specify. Note that in this way, all items are of the same length 10. Also in this way, all necessary storage (2 * 10 * sizeof(char)) is allocated upfront.

    The items1 can only be passed to print2D_1():
        void print2D_1(char strs[][10], int strsSize);
    It is NOT OK to pass items1 to print2D_2():
        void print2D_2(char** strs, int strsSize);
    Even casting items1 to char** type and passing to print2D_2() is NOT OK:
        print2D_2((char **)items1, 2);
    */
    char items1[][10] = {"Hello,", "world!"};
    print2D_1(items1, 2);

    /* 2D version 2:
    Use an array of pointers to hold multiple strings.
    But the following definition/initialization is NOT OK
        char** items2 = {"Hello,", "world!"};
    This means even though we know char* [] will be converted to char**, but we cannot just define char** items2 and initialize it as an array of pointers.
    */
    char* items2[] = {"Hello,", "world!"};
    print2D_2(items2, 2);

    /* 2D version 2.1:
    Use an array of pointers to hold multiple strings.
    Allocate storage with dynamic allocation.
    */
    int rows = 2, cols = 10;
    char** items2_1 = (char **) malloc(rows * sizeof(char*));
    char* items_arr[] = {"Hello,", "world!"};
    if (!items2_1) {
        printf("items2_1 is null because malloc() failed!\n");
        exit(1);
    }
    for (int i = 0; i < rows; i++) {
        items2_1[i] = (char *) malloc(cols * sizeof(char));
        if (!items2_1[i]) {
            printf("items2_1[%d] is null because malloc() failed!\n", i);
            exit(1);
        }
        strcpy(items2_1[i], items_arr[i]);
    }
    print2D_2_1(items2_1, rows);

    for (int i = 0; i < rows; i++)
        free(items2_1[i]);
    free(items2_1);

    /* 2D version 2.2:
    Use an array of pointers to hold multiple strings.
    Mix dynamic allocation and static allocation. Only rows number of pointers are dynamically allocated. Instead of dynamically allocating space for each row pointer, each row pointer points to a static unnamed string literal (likely allocated in read-only memory).
    */
    rows = 2;
    char** items2_2 = (char **) malloc(rows * sizeof(char*));
    //char* items_arr[] = {"Hello,", "world!"};
    if (!items2_2) {
        printf("items2_2 is null because malloc() failed!\n");
        exit(1);
    }
    for (int i = 0; i < rows; i++)
        items2_2[i] = items_arr[i];
    print2D_2_2(items2_2, rows);
    free(items2_2);

    /* 2D version 2.3:
    This way is a nice compromise. Here items2_3 can be defined as 2D array and easily initialized. Then we cast items2_3 as a char* and pass to print2D_2_3(). Since we are not passing array dimensions any more, we need to pass the bounds seperately as strsSize and colSize.
        void print2D_2_3(char* strs, int strsSize, int colSize);
    */
    char items2_3[][10] = {"Hello,", "world!"};
    print2D_2_3((char*)items2_3, 2, 10);

    /* 3D version 1:
    Use 3-dimentional array.
    Note: an multidimensional array must have bounds for all dimensions except the first!
    */
    char items3[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}};
    print3D_1(items3, 2);

    /* 3D version 2:
    Use a 2D array of pointers.
    It is a little better than 3D array as at least we only need to give one bound.
    Note: we can NOT define items4 as below:
        char** items4[] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}};
    */
    char* items4[][3] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}};
    print3D_2(items4, 2);

    /* 3D version 3:
    Use array of pointers with dynamic allocation.
    First allocate space for 1 pointer to hold items5 (char ***).
    Secondly allocate space for 2 pointers to hold items5[0] and items5[1] (char **).
    Thirdly allocate space for 6 pointers to hold items5[0][0]...items5[]1[2] (char *).
    Lastly allocate space for 6 strings (10 chars max each) and save their addresses to the 6 pointers allocated above.
    Therefore, in all, there are 9 pointers in play.
    */
    //char items3[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}};
    int d1 = 2, d2 = 3, d3 = 10;
    char*** items5 = (char ***)malloc(d1 * sizeof(char**));
    if (!items5) {
        printf("items5 is null because malloc() failed!\n");
        exit(1);
    }

    for (int i = 0; i < d1; i++) {
        items5[i] = (char **)malloc(d2 * sizeof(char*));
        if (!items5[i]) {
            printf("items5[%d] is null because malloc() failed!\n", i);
            exit(1);
        }
    }

    for (int i = 0; i < d1; i++)
        for (int j = 0; j < d2; j++) {
            items5[i][j] = (char *)malloc(d3 * sizeof(char));
            if (!items5[i][j]) {
                printf("items5[%d][%d] is null because malloc() failed!\n", i, j);
                exit(1);
            }
            strcpy(items5[i][j], items3[i][j]);
        }
    
    print3D_3((char ***)items5, d1, d2);

    for (int i = 0; i < d1; i++)
        for (int j = 0; j < d2; j++)
            free(items5[i][j]);
    for (int i = 0; i < d1; i++)
        free(items5[i]);
    free(items5);

    /* 3D version 3.1: Not OK!
    Convert the 3D array to 1D array and pass to print3D_3_1() as char *.
    This one didn't work as expected and prints something like below, which is NOT correct!
    3D_3_1: phone  blue  computer
    3D_3_1:
    */
    //int d1 = 2, d2 = 3, d3 = 10;
    //char items3[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}};
    print3D_3_1((char *)items3, d1, d2, d3);

    return 0;
}



/*
1773. Count Items Matching a Rule
1773_count_items_matching.c

You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.
The ith item is said to match the rule if one of the following is true:
ruleKey == "type" and ruleValue == typei.
ruleKey == "color" and ruleValue == colori.
ruleKey == "name" and ruleValue == namei.
Return the number of items that match the given rule.

Example 1:
Input: items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
Output: 1
Explanation: There is only one item matching the given rule, which is ["computer","silver","lenovo"].

Example 2:
Input: items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
Output: 2
Explanation: There are only two items matching the given rule, which are ["phone","blue","pixel"] and ["phone","gold","iphone"]. Note that the item ["computer","silver","phone"] does not match.

Constraints:
1 <= items.length <= 104
1 <= typei.length, colori.length, namei.length, ruleValue.length <= 10
ruleKey is equal to either "type", "color", or "name".
All strings consist only of lowercase letters.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
Version 1
This version works when items is defined/initialized as below:
    char items1[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}, {"phone","gold","iphone"}};

This version can NOT pass the official tester because it does NOT math the required signature below:
    int countMatches(char ***items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue);
*/
int countMatches_1(char items[][3][10], int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue){
    int cnt = 0;
    int itemsCol = 0;

    if (!strcmp(ruleKey, "type")) itemsCol = 0;
    else if (!strcmp(ruleKey, "color")) itemsCol = 1;
    else itemsCol = 2;

    for (int i = 0; i < itemsSize; i++) {
        if (!strcmp(items[i][itemsCol], ruleValue)) cnt++;
    }

    return cnt;
}

/*
Version 2
*/
int countMatches(char ***items, int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue){
    int cnt = 0;
    int itemsCol = 0;

    if (!strcmp(ruleKey, "type")) itemsCol = 0;
    else if (!strcmp(ruleKey, "color")) itemsCol = 1;
    else itemsCol = 2;

    for (int i = 0; i < itemsSize; i++) {
        if (!strcmp(items[i][itemsCol], ruleValue)) cnt++;
    }

    return cnt;
}

/* Version 1: NOT OK!
This version of main() requires the follow countMtches(), which is NOT OK for the official tester:
    int countMatches_1(char items[][3][10], int itemsSize, int* itemsColSize, char * ruleKey, char * ruleValue);
*/
int main_1() {
    int count = 0;
    int itemsColSize = 3;
    char items1[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}, {"phone","gold","iphone"}};
    char* ruleKey1 = "color";
    char* ruleValue1 = "silver";

    count = countMatches_1(items1, 3, &itemsColSize, ruleKey1, ruleValue1);
    printf("count = %d\n", count);

    return 0;
}

/* Version 2
Example 1:
Input: items = [["phone","blue","pixel"],["computer","silver","lenovo"],["phone","gold","iphone"]], ruleKey = "color", ruleValue = "silver"
Output: 1
Explanation: There is only one item matching the given rule, which is ["computer","silver","lenovo"].

Example 2:
Input: items = [["phone","blue","pixel"],["computer","silver","phone"],["phone","gold","iphone"]], ruleKey = "type", ruleValue = "phone"
Output: 2
Explanation: There are only two items matching the given rule, which are ["phone","blue","pixel"] and ["phone","gold","iphone"]. Note that the item ["computer","silver","phone"] does not match.
*/
int main() {
    int count = 0;
    int d1 = 3, d2 = 3, d3 = 10;
    char static_items1[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","lenovo"}, {"phone","gold","iphone"}};
    char static_items2[][3][10] = {{"phone","blue","pixel"}, {"computer","silver","phone"}, {"phone","gold","iphone"}};
    char* ruleKey1 = "color";
    char* ruleKey2 = "type";
    char* ruleValue1 = "silver";
    char* ruleValue2 = "phone";

    char*** items = (char ***)malloc(d1 * sizeof(char **));
    for (int i = 0; i < d1; i++){
        items[i] = (char **)malloc(d2 * sizeof(char *));
        for (int j = 0; j < d2; j++)
            items[i][j] = static_items1[i][j];
    }

    count = countMatches((char ***)items, d1, &d2, ruleKey1, ruleValue1);
    printf("count1 = %d\n", count);

    for (int i = 0; i < d1; i++){
        for (int j = 0; j < d2; j++)
            items[i][j] = static_items2[i][j];
    }

    count = countMatches((char ***)items, d1, &d2, ruleKey2, ruleValue2);
    printf("count2 = %d\n", count);

    for (int i = 0; i < d1; i++)
        free(items[i]);
    free(items);

    return 0;
}




/*
1859. Sorting the Sentence
1859_sorting_sentence.c

A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.
A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.

For example, the sentence "This is a sentence" can be shuffled as "sentence4 a3 is2 This1" or "is2 sentence4 This1 a3".
Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.

Example 1:
Input: s = "is2 sentence4 This1 a3"
Output: "This is a sentence"
Explanation: Sort the words in s to their original positions "This1 is2 a3 sentence4", then remove the numbers.

Example 2:
Input: s = "Myself2 Me1 I4 and3"
Output: "Me Myself and I"
Explanation: Sort the words in s to their original positions "Me1 Myself2 and3 I4", then remove the numbers.

Constraints:
2 <= s.length <= 200
s consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9.
The number of words in s is between 1 and 9.
The words in s are separated by a single space.
s contains no leading or trailing spaces.
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_NUM_WORDS 9
#define MAX_WORD_LEN 200

/*
Version 1
*/
char * sortSentence_1(char * s){
    char temp[MAX_NUM_WORDS][MAX_WORD_LEN] = {};
    int temp_word_len[MAX_NUM_WORDS] = {0};
    int cnt = 0;

    char* out = (char *)malloc(MAX_WORD_LEN * sizeof(char));
    if (!out) {
        printf("out is null, malloc() failed!\n");
        exit(1);
    }
    
    for (char *p = s, *q = s; p - s <= strlen(s); p++) {
        if (*p != ' ' && *p != '\0') continue;
        int i = *(p - 1) - '0' - 1;
        int len = p - q - 1;
        strncpy(temp[i], q, len);
        temp_word_len[i] = len;
        cnt++;
        q = p + 1;
    }

    char* p = out;
    for (int i = 0; i < cnt; i++) {
        strncpy(p, temp[i], temp_word_len[i]);
        p += temp_word_len[i];
        *p = ' '; p++;
    }
    *(--p) = '\0';

    return out;
}

/*
Version 2
No need to use temp_word_len[]. Since the array temp[][] is initialized to all 0, when we strncpy each word to it, each temp[] entry (each word) will have proper ending null char. Therefore there is no need to record each word's length.
In the second for loop, we can just use strcpy() instead of strncpy() since each temp[i] has a proper traling null char in place.

Note: strcpy() will copy the trailing null char while strncpy() will not if n <= strlen(source).
*/
char * sortSentence(char * s){
    char temp[MAX_NUM_WORDS][MAX_WORD_LEN] = {};
    int cnt = 0;

    char* out = (char *)malloc(MAX_WORD_LEN * sizeof(char));
    if (!out) {
        printf("out is null, malloc() failed!\n");
        exit(1);
    }
    
    for (char *p = s, *q = s; p - s <= strlen(s); p++) {
        if (*p != ' ' && *p != '\0') continue;
        int i = *(p - 1) - '0' - 1;
        int len = p - q - 1;
        strncpy(temp[i], q, len);
        cnt++;
        q = p + 1;
    }

    char* p = out;
    for (int i = 0; i < cnt; i++) {
        strcpy(p, temp[i]);
        p += strlen(temp[i]);
        *p = ' '; p++;
    }
    *(--p) = '\0';

    return out;
}

/*
Example 1:
Input: s = "is2 sentence4 This1 a3"
Output: "This is a sentence"
Explanation: Sort the words in s to their original positions "This1 is2 a3 sentence4", then remove the numbers.

Example 2:
Input: s = "Myself2 Me1 I4 and3"
Output: "Me Myself and I"
Explanation: Sort the words in s to their original positions "Me1 Myself2 and3 I4", then remove the numbers.
*/
int main() {
    char *s1 = "is2 sentence4 This1 a3", *s2 = "Myself2 Me1 I4 and3";

    char *out1 = sortSentence(s1);
    printf("out1: %s\n", out1);

    char *out2 = sortSentence(s2);
    printf("out2: %s\n", out2);

    free(out1); free(out2);
    return 0;
}









